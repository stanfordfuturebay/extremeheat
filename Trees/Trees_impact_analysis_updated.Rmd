---
title: "Trees Impact Analysis 2.0"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(sf)
library(sp)
library(dplyr)
library(tigris)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
SCC_trees <- read.csv("SCC_trees.csv")
OCF <- read.csv("OCF.csv")
```

Ignore: Convert into an sf dataframe
```{r}
# # SCC_trees_sf <- SCC_trees %>% 
# #   st_as_sf(coords = c("Longitude", "Latitude"),
# #            crs = 4326)
# # 
# # mapview::mapview(SCC_trees_sf)
# 
# #check out the NA lat and longs
# ocf_na <- OCF[is.na(OCF$Latitude),]
# 
# #let's remove NAs for now and check out the points
# ocf_no_na <- OCF[!is.na(OCF$Latitude),]
# 
# projection <- "+proj=utm +zone=10 +ellps=GRS80 +datum=NAD83 +units=ft +no_defs"
# 
# OCF_sf <- ocf_no_na %>% 
#   st_as_sf(coords = c("Longitude", "Latitude"),
#            crs = 4326) %>% 
#   st_transform(projection)
# 
# mapview::mapview(OCF_sf)
# #check out the area of the circles. I don't think there will be a difference tbh
# OCF_sf <- OCF_sf %>% 
#   mutate(
#     area = st_area(OCF_sf)
#   )
# 
# sites_type <- OCF_sf[!is.na(OCF_sf$Site.Type),4]
# sites_type <- sites_type[!duplicated(sites_type$Site.Type),]
# 
# SCC_trees_sf$Original.Inventory.Date <- SCC_trees_sf$Original.Inventory.Date %>% 
#   as.Date(
#     "%m/%d/%Y"
#   ) #the range of dates are from "2018-03-15" "2020-08-24"
# 
# #so maybe grab NDVI values from 2017? as the past event and maybe from 2020 and exclude trees that were just planted in 2020?
```

Grabbing the number of trees for each site
```{r}
#first grabbing a data frame that has only the number of trees mentioned
#assign row 8320 lat and long: 37.31244111310448, -121.81560333615958
#assign row 8289 lat and long: 37.26831482031106, -121.87191638104785
#assign row 7965 lat and long: 37.32544447366333, -121.77615170405979
#assign row 2075 lat and long: 37.39203678910142, -121.84883980385966
#row 3255 doesn't have a street identifier
OCF[8320, 13] <- 37.31244
OCF[8320, 14] <- -121.81560

OCF[8289, 13] <- 37.26831
OCF[8289, 14] <- -121.87191

OCF[7965, 13] <- 37.32544
OCF[7965, 14] <- -121.77615

OCF[2075, 13] <- 37.39203
OCF[2075, 14] <- -121.84884

OCF_trees <- OCF[!is.na(OCF$Total.Trees.Planted),]

OCF_trees <- OCF_trees[!is.na(OCF_trees$Latitude),]

OCF_trees$Original.Inventory.Date <- OCF_trees$Event.Date %>% 
  as.Date(
    "%m/%d/%Y"
  )

#the range of dates are: "1994-01-01" "1999-12-29"
range(OCF_trees$Original.Inventory.Date)

#now creating it into a spatial object
OCF_trees_sf <- OCF_trees %>% 
  st_as_sf(coords = c("Longitude", "Latitude"),
           crs = 4326)
```

```{r}
#now I will do a spatial join to assign census block groups to these rows
scc_block_groups <- 
  block_groups("CA", "Santa Clara", cb = T, progress_bar = F)
scc_block_groups <- scc_block_groups %>% 
  select(
    GEOID
  )
#set coordinate reference system to be the same
scc_block_groups <- scc_block_groups %>% 
  st_transform(st_crs(OCF_trees_sf))
```

```{r}
#now it's the spatial join to identify each site project to a CBG
OCF_trees_sf <- OCF_trees_sf %>% 
  st_join(scc_block_groups)
```


```{r}
#Now group by and summarize the number of trees
trees_count <- OCF_trees_sf %>% 
  group_by(
    GEOID
  ) %>% 
  summarise(
    total_trees = sum(Total.Trees.Planted)
  ) %>% 
  st_drop_geometry() #there's one row with no GEOID
```

Now it's grabbing the NDVI info from when OCF started planting trees to now
```{r}
library(rgee)

```

```{r}
ee_Initialize()
ee_check()
```

```{r}
counties <- ee$FeatureCollection("TIGER/2016/Counties")
myfilter <- ee$Filter$inList(
  opt_leftField = "NAME",
  opt_rightValue = list(
    "Santa Clara"
  )
)

ba_counties <- counties$filter(myfilter)
```

```{r}
cloud_mask <- function(raster_comp){
  #this reassigns cloud shadow pixels to clear pixels
  cloudShadowBitMask <- bitwShiftL(1,3)
  
  #this reassigns cloud pixels to be clear
  cloudsBitMask <- bitwShiftL(1,5)
  
  #this reassigns water pixelx to clear pixels
  waterBitMask <- bitwShiftL(1,2)
  
  #select pixel_qa band and set it to a variable
  qa <- raster_comp$select('pixel_qa')
  
  #Multiplies the bits in the original pixel_qa band by the new reassigned cloud shadow transparent bits
  mask <- qa$bitwise_and(cloudShadowBitMask)$eq(0)$
    And(qa$bitwise_and(cloudsBitMask)$eq(0))$
    And(qa$bitwise_and(waterBitMask)$eq(0))
  
  #The cloud cover and cloud shadow pixels now have bit values of 1 = transparent
  #Transparent pixels will not be include in the further analysis
  raster_comp$updateMask(mask)
}



```

Grabbing NDVI values for 1994, 1999, and 2020
```{r}
years_all <- data.frame(
  years_start = c(as.Date("1994-01-01"), as.Date("1999-01-01"), as.Date("2020-01-01")) %>% 
    as.character(),
  years_end =   c(as.Date("1994-12-31"), as.Date("1999-12-31"), as.Date("2020-12-31")) %>% 
    as.character(),
  years = c("1994", "1999", "2020")
)
```

Using Landsat 5 for 1994 data (Landsat 7 starts from 1999)
```{r}
  ndvi_l5srt_combo <- ee$ImageCollection("LANDSAT/LT05/C01/T1_SR")$ #Grabbing landsat 7 surface reflectance data
  filterBounds(ba_counties)$ #filtering within the bay area counties
  filterDate(years_all$years_start[1], years_all$years_end[1])$ #filter for the start and finish dates
  map(cloud_mask)$ #clear the clouds, cloud shadows, and water
  median()$ #create a median image from the image collection
  normalizedDifference(c('B4', 'B3'))$rename("ndvi") #calculate ndvi based on the image's band 5 and band 4 and rename the band "ndvi"

  ndvi_bay_area <- ee_extract(
   x = ndvi_l5srt_combo,
   y = scc_block_groups["GEOID"],
   scale = 30,
   fun = ee$Reducer$mean(),
   sf = TRUE
  )
  
  #create unique dataframes to later bind
  assign(paste0("ndvi_bay_area_", years_all$years[i], sep = ""), ndvi_bay_area)
  
  #Save! Especially if you have bad wifi!!!!!!
  saveRDS(ndvi_bay_area, paste0("ndvi_bay_area_", years_all$years[i], ".rds"))
  
  #print for your own sanity
  print(i)
```


```{r}
for (i in 2:nrow(years_all)){
  ndvi_l7srt_combo <- ee$ImageCollection("LANDSAT/LE07/C01/T1_SR")$ #Grabbing landsat 7 surface reflectance data
  filterBounds(ba_counties)$ #filtering within the bay area counties
  filterDate(years_all$years_start[i], years_all$years_end[i])$ #filter for the start and finish dates
  map(cloud_mask)$ #clear the clouds, cloud shadows, and water
  median()$ #create a median image from the image collection
  normalizedDifference(c('B4', 'B3'))$rename("ndvi") #calculate ndvi based on the image's band 5 and band 4 and rename the band "ndvi"

  ndvi_bay_area <- ee_extract(
   x = ndvi_l7srt_combo,
   y = scc_block_groups["GEOID"],
   scale = 30,
   fun = ee$Reducer$mean(),
   sf = TRUE
  )
  
  #create unique dataframes to later bind
  assign(paste0("ndvi_bay_area_", years_all$years[i], sep = ""), ndvi_bay_area)
  
  #Save! Especially if you have bad wifi!!!!!!
  saveRDS(ndvi_bay_area, paste0("ndvi_bay_area_", years_all$years[i], ".rds"))
  
  #print for your own sanity
  print(i)
}
```

Now that I have the data, I will read it in and bind it to the dataframe we have for the amount of trees.
```{r}
#read in the ndvi data
ndvi_94 <- readRDS("G:/Shared drives/SFBI-Restricted/W21 218Y Tree Team/Trees_impact/ndvi_bay_area_1994.rds") %>% 
  rename(
    ndvi_1994 = "ndvi"
  )
ndvi_99 <- readRDS("G:/Shared drives/SFBI-Restricted/W21 218Y Tree Team/Trees_impact/ndvi_bay_area_1999.rds")  %>% 
  rename(
    ndvi_1999 = "ndvi"
  )
ndvi_20 <- readRDS("G:/Shared drives/SFBI-Restricted/W21 218Y Tree Team/Trees_impact/ndvi_bay_area_2020.rds")  %>% 
  rename(
    ndvi_2020 = "ndvi"
  )

trees_data <- readRDS("/Volumes/GoogleDrive/Shared drives/SFBI-Restricted/W21 218Y Tree Team/Trees_impact/trees_data.rds")
  
```

```{r}
trees_data <- trees_data %>%
  rename(ndvi_1999 = "ndvi_99.ndvi_1999", ndvi_2020 = "ndvi_20.ndvi_2020") %>%
  mutate(ndvi_diff = ndvi_2020 - ndvi_1994)
```

```{r}
trees_data_no_na <- 
  trees_data %>%
  filter(!is.na(total_trees))
```


```{r}
#Mapping difference in NDVI from 1994-2020
library(leaflet)
library(htmlwidgets)

pal <- colorNumeric(
  palette = "YlGn",
  domain = 
    trees_data_no_na$ndvi_diff
)

ndvi_diff <- leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = trees_data_no_na,
    fillColor = ~pal(ndvi_diff),
    color = "white",
    opacity = 0.5,
    fillOpacity = 0.5,
    weight = 1,
    label = ~paste0(
      ndvi_diff, 
      " NDVI Difference ",
      GEOID
    ),
    highlightOptions = highlightOptions(
      weight = 2,
      opacity = 1
    )
  ) %>% 
  addLegend(
    data = trees_data_no_na,
    pal = pal,
    values = ~ndvi_diff,
    title = "Difference in NDVI, 1994-2020"
  )

saveWidget(ndvi_diff, "ndvi_diff.html", selfcontained = T)
```


```{r}
#Mapping total number of trees in each block group

trees_data_no_outlier <- trees_data_no_na %>%
  filter(!total_trees == 1872)

trees_data_outlier <- trees_data_no_na %>%
  filter(total_trees == 1872)

trees_pal <- colorBin(
  palette = colorRamp(c("#c3e4f7", "#4682bf"), interpolate="spline"),
  bins = c(1, 10, 25, 50, 100, 200, 500),
  domain = 
    trees_data_no_outlier$total_trees
)


tree_map <- leaflet() %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = trees_data_no_outlier,
    fillColor = ~trees_pal(total_trees),
    color = "white",
    opacity = 0.5,
    fillOpacity = 0.5,
    weight = 1,
    label = ~paste0(
      total_trees, 
      " in ",
      GEOID
    ),
    highlightOptions = highlightOptions(
      weight = 2,
      opacity = 1
    )
  ) %>% 
  addPolygons(
    data = trees_data_outlier,
    fillColor = "red",
    color = "white",
    opacity = 0.5,
    fillOpacity = 0.5,
    weight = 1,
    label = ~paste0(
      total_trees, 
      " in ",
      GEOID
    ),
    highlightOptions = highlightOptions(
      weight = 2,
      opacity = 1
    )
  ) %>%
  addLegend(
    data = trees_data_no_outlier,
    pal = trees_pal,
    values = ~total_trees,
    title = "Total Number of Trees"
  )
saveWidget(tree_map, "tree_map.html", selfcontained = T)
```

```{r}
#scatter plot of total trees planted vs. diff in NDVI from 1994-2020 for 280 census block groups. 

library(ggplot2)

trees_data_no_outlier %>% 
  ggplot(
    aes(
      x = total_trees,
      y = ndvi_diff
    )
  ) +
  geom_point() +
  geom_smooth(method = "lm") + 
  labs(
    x = "Total Trees Planted",
    y= "Difference in NDVI",
    title = "Total Trees Planted in SCC Census Block Groups vs. NDVI change from 1994 to 2020"
  )
```


Now I can show a map? Of the difference in ndvi? 

Showing a linear plot of ndvi from 1994 by census block groups

can create a map of the number of trees by census block group

can create a leaflet map of the difference in NDVI (2020 minus 1994 values) by census block group

Questions: could the data from OCF possibly be in the SCC Tree Plotter data? If so, maybe we can grab more information like the condition of the trees and when the trees were last inspected (this is from OCF data)




